# method 1: binary search
- in range max and min directly search the value satify the condition function that how many elements is smaller or equal to the value
- then we search k largest which is n+1-k number of elements <= the value

## complextity analysis
- time: O(n*log(max-min))
- space: O(1)

## code
```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int l = *min_element(nums.begin(), nums.end()), r = *max_element(nums.begin(), nums.end()), n = nums.size();
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (count(mid, nums) >= n + 1 - k) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
    
    // count how many elements >= value
    int count(int value, vector<int> & nums) {
        int cnt = 0;
        for (int n : nums) {
            if (n <= value) cnt++;
        }
        return cnt;
    } 
};
```

